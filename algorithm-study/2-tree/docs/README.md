# 树

树的遍历
- [后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)
- [前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/description/)
- [层次遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

高度指节点到根节点的路径长;
深度指节点到叶子节点的最大路径长.

## 二叉树

- 二叉查找树
- AVL平衡二叉树
- 伸展树

二叉树的遍历:
- [前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
- [中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
- [后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

### 二叉查找树

左子树的所有节点 < 父节点 < 右子树的所有节点
平均深度为$\log_2N$

- 元素**可比较**
- **中序遍历**为升序排列

针对有两个儿子的节点, 一般的删除策略是用右子树的最小节点数据代替改节点的数据, 
然后再递归的删除那个最小节点; 由于右子树的最小节点是没有左儿子的, 
最多可能有一个儿子, 所以删除操作很简单.

如果删除次数不多, 则通常采用惰性删除, 当树中的实际节点数和"被删除节点数"相同时, 
树的深度预计只上升一个小的常数.

### AVL平衡二叉树

平衡的目的是使任何节点的深度不得过深.

AVL树要求左右子树的高度最多差1, 
空树的高度定义为-1.

在插入/删除操作导致平衡被破坏, 则需要通过**旋转**来修正.

单旋:
- 左左情况, 由节点的左节点的左节点导致该节点平衡被破坏
    1. 节点的左节点提升为父节点
    2. 原来的父节点成为左节点的右节点
    3. 原来左节点的右节点成为原来父节点的左节点
- 右右情况, 由节点的右节点的右节点导致该节点平衡被破坏
    1. 节点的右节点提升为父节点
    2. 原来的父节点成为右节点的左节点
    3. 原来右节点的左节点成为原来父节点的右节点  

双旋:
- 左右情况,
    1. 节点的左子树提升到父节点
    2. 将原来的父节点成为左节点的右节点的右节点, 即右右情况
    3. 对右右情况进行单旋处理
- 右左情况,
    1. 节点的右子树提升到父节点
    2. 将原来的父节点成为右节点的左节点的左节点, 即左左情况
    3. 对左左情况进行单旋处理

## B树

如果数据量太大, 导致主存都装不下, 那么也即是说需要把数据放在磁盘上,
这时大O模型(大O假设所有的操作耗时相等)就不再适用了, 
因为处理器的速度远远大于磁盘的速度, 为了节省一次磁盘访问, 
宁愿进行大量的计算. 

***几乎所有情况下, 控制运行时间的都是控制磁盘的访问次数***; 
如果磁盘的访问次数减少一半, 那么运行时间也将减半.

一颗M叉查找树可以有M路分支, 随着分支的增加, 树的深度在减小,
一个M叉树的高度大约$\log_MN$.

原则上B树保证只有少数的磁盘访问, 它的特点:
- 数据项存储在叶子节点
- 非叶子节点存储M-1个关键字, 用来指示搜索方向;
关键字i表示子树i+1中的最小值
- 根节点要么是一个叶节点, 要么儿子数在2和M之间
- 除根外, 其他非叶子节点的儿子树为$[\lceil M/2 \rceil, M]$,
要求节点半满是为了不至于退化为简单的二叉树
- 所有树叶的深度相同, 并有$[\lceil L/2 \rceil, L]$个数据项

每个节点代表一个区块, 根据区块可容纳的大小, 以及每个数据项的大小, 
来计算M和L.

添加数据项导致根节点**分裂**为两个节点, 并创建新的根节点关联这两个节点, 
这是B树增加高度的唯一方式

删除数据项导致根节点下的儿子**合并**后只有一个节点, 则删除根节点, 
提升儿子节点为新的根节点, 这是B树减小高度的唯一方式.





